---
title: 浏览器
date: 2022-12-4 10:36:15
tags: 学习
categories: 前端
top: 997
typora-copy-images-to: upload
---

### 浏览器的本地储存

浏览器的本地储存主要分为Cookie、localStorage、sessionStorage和IndexedDB

<!--more-->

#### Cookie

Cookie最开始标识用来做本地存储的，是为了弥补HTTP在状态管理上的不足。Cookie本质是浏览器上存储的一个小文件，在内部以键值对的方式来储存，在同一个域名下发送请求，都会携带相同的Cookie。服务器拿到Cookie进行解析便能字段客户端的状态

**Cookie的缺陷：**

- 容量缺陷，Cookie只能储存4kb的文件，信息量非常的少
- 性能缺陷，Cookie紧跟着域名，不管域名下的某一个地址需不需要Cookie，请求都会带上这个Cookie。这样就造成了很大的性能浪费
- 安全缺陷，由于Cookie和服务端都是以文本的形式进行交互，很容易被非法用户截获并加以修改

#### localStorage

localStorage和Cookie有点相似，都是针对同一个域名，会储存相同的一段信息

**localStorage相比Cookie的区别：**

- 容量，localStorage的容量上限为5M
- localStorage的信息只存储在客户端，默认不参与和服务端的通信
- 接口封装，通过localStorage暴露在全局，通过它的setItem和getItem等方法进行操作，非常的方便

**使用方法**

```javascript
let obj = { name: "sanyuan", age: 18 };
localStorage.setItem("name", "sanyuan"); 
localStorage.setItem("info", JSON.stringify(obj));
//取值
let name = localStorage.getItem("name");
let info = JSON.parse(localStorage.getItem("info"));
//localStorage存储的都是字符串，如果想要存储对象的话需要使用JSON的stringify方法处理，然后再利用JSON的parse方法解析成对象。
```

**应用场景**

利用localStorage的较大容量和持久特性，可以利用localStorage存储一些内容稳定的资源**。**

localStorage和Cookie有点相似，都是针对同一个域名，会储存相同的一段信息

#### sessionStorage

sessionStorage基本和localStorage基本一致，只有一个最本质的区别，sessionStorage知识会话级的储存，并不是持久化存储。会话结束，也就是页面关闭sessionStorage的信息就会消失

**应用场景**

- 可以用来对表单信息进行维护，将表单的信息存储在里面，可以让页面刷新之后也不会让之前的表单信息消失
- 可以用来存储本次浏览记录

sessionStorage基本和localStorage基本一致，只有一个最本质的区别，sessionStorage知识会话级的储存，并不是持久化存储。会话结束，也就是页面关闭sessionStorage的信息就会消失

#### IndexedDB

IndexedDB是运行在浏览器中的非关系数据库，本质上数据库，存储容量没有上限。IndexedDB除了拥有数据库本身的一些特性，如支持事务和存储二进制还有一些其他的特性

**额外特性：**

- 键值对存储，内部采用对象仓库存放数据
- 异步操作，数据库的读写数据I/O操作，浏览器中对异步I/O提供了支持
- 受同源策略限制，无法访问跨域的数据库

### 浏览器的请求过程

当你在浏览器地址栏输入了`https://www.baidu.com/`

#### 构建请求行

浏览器会自动构建好请求行

```javascript
GET / HTTP/1.1
```

#### 查找强缓存

先查看浏览器有没有强缓存，有的话就直接使用浏览器缓存中的资源。没有则继续进行请求

#### DNS解析

因为一开始输入的是域名，所以我们要得到域名对应的IP地址。这个过程就是DNS解析。浏览器提供了DNS数据缓存功能

如果一个域名解析过了，第二次就会直接调用缓存。如果没有指定的端口，默认采用80端口

#### 建立TCP连接

TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议

注意Chrome在同一个域名下要求最多只能有6个TCP连接，超过6个的话就需要等待

**建立TCP经历了下面三个阶段：**

**三次握手建立连接**

刚开始客户端处于Closed的状态，服务端处于Listen状态

第一次握手：客户端给服务端发一个SYN报文，并指明客户端的初始化序列号ISN。此时客户端处于SYN_SEND状态

第二次握手：服务器收到客户端的SYN报文之后，会以自己的SYN报文作文应答，并且也是指定了自己的初始化序列号ISN(s)。同时会把客户端的ISN+1作为ACK的值，表示自己已经收到了客户端的SYN，此时服务器处于SYN_REVD的状态

第三次握手：客户端收到SYN报文之后，会发送一个ACK报文，也是把ISN+1作为ACK的值，表示已经收到了服务端的SYN报文，此时客户端处于EASTABLISHED的状态。服务器收到ACK报文后，也处于EASTABLISHED状态。此时，双方已建立起了连接

**数据传输**

发送方发一个数据包，接受方接受到数据包之后必须要向发送发确认，如果发送方没有收到这个确认消息，就判定为数据包丢失，并重新发该数据包。把大的数据包拆成小的数据包传输可以提高效率

#### 四次挥手断开连接

刚开始客户端和服务端都处于EASTABLISHED状态客户端和服务端均可主动发起挥手动作

第一次挥手：客户端发送一个FIN报文，报文中会指定一个序列号。此时客户端处于FIN_WAIT1状态

第二次挥手：服务端收到FIN之后，会发送ACK报文，且把客户端的序列号值+1作为ACk报文的序列值，表明已经收到客户端的报文了，此时服务端处于CLOSE_WAIT状态

第三次挥手：如果服务端也想断开连接了，和客户端的第一次握手一样，发给FIN报文，并且指定一个序列号。此时服务端处于LAST_ACK的状态

第四次挥手：客户端收到FIN之后，一样发送一个ACK报文作为应答，且把服务端的序列号值+1作为自己ACK报文的序列值，此时客户端处于TIME_WAIT状态。需要过一段时间确保服务器收到自己的ACK报文后才会进入CLOSED状态。服务端收到ACK报文后处于CLOSED状态

#### 发送HTTP请求（如果请求头或者响应头中包含Connection: Keep-Alive表示建立了持久连接，tcp连接会一直保持）

TCP连接建立好，浏览器就可以和服务器开始通信，浏览器HTTP请求需要携带三个东西：请求行（第一步的时候浏览器创建好了）、请求头和请求体（只有再POST方法下存在）

**网络响应**

HTTP请求到达服务器，服务器进行对应的处理。最后要把数据传给浏览器，也就是返回网络响应。网络响应包括三个部分：响应行、响应头和响应体

响应行，HTTP/1.1 200 OK由HTTP协议、状态码和状态描述组成

响应头，响应头包含了服务器及其返回数据的一些信息、服务器生成数据的时间、返回的数据类型以及对即将写入的Cookie信息

响应体，服务端传给客户端的数据

### 构建渲染树过程

#### 构建DOM树

由于浏览器无法直接理解HTML字符串，因此将这一系列字节流转换成一种有意义并且方便操作的数据结构，这种结构就是DOM树，也可以理解为一个以document为根节点的多叉树

常规的编程语言都是上下文无关的，而HTML却相反。所以HTML不能使用常规编程语言的解析器来完成

**标记化算法**

标记化算法输入为HTML文本，输出为HTML标记，成为标记生成器。这个是通过有限自动状态机来完成的，既在当前状态下，接受一个或多个字符，就会更新到下一个状态。下面是一个简单的标记化过程的示例

遇到<，状态为标记打开状态

遇到[a-z]的字符，会进入标记名称状态

遇到\>，表示标记名称记录完成，这时候变为数据状态

在遇到<，表示数据记录完成，状态又变成标记打开状态

紧接着遇到下一个/后，会创建一个end tag的token，进入到标记名称状态

遇到\>，回到数据状态

**建树算法**

标记生成器会把每个标记的信息发送给建树器。建树器接受到相应的标记时，会创建相应的DOM对象。然后将DOM对象加入DOM树中然后将对应标记压入存放元素的栈中。下面是建树的实例

首先是初始状态

接受到标记生成器传来的html标签，这个时候状态变成before html状态。同时创建一个HTMLHtmlElement的DOM元素，将其加到document根对象上，并进行压栈操作

接着状态自动变为before head，此时从标记生成器那边传来body，表示并没有head，这时候建树器会自动创建一个HTMLHeadElement并将其加入到Dom树中

接着进入大in head状态，然后直接跳到after head状态

接着标记生成器传来了body标记，创建HTMLBodyElement，插入到DOM树中，同时压入开放标记栈。状态变为in body

然后接受后面的一系列字符：hello world，接受第一个时会先创建一个text节点并把Text节点插入搭配DOM树中body元素的下面

现在标记生成器传来body的接受标记，进入after body状态

标记生成器在传一个html的接受标记，进入搭配after after body状态，解析过程到此结束

#### 样式计算

**样式来源**

主要有以下三种，link标签引用、style标签中的样式和元素的内嵌style属性

**格式化样式表**

首先浏览器是无法识别css样式文件的，渲染引擎接收到css文本之后第一件事就是将其转化为一个结构化的对象，即styleSheets。浏览器控制台能通过document.styleSheets来查看这个最终的结构

**标准化样式属性**

有一些css样式的数值不能被浏览器所理解，因为要在计算样式之前将他们都标准化，如em ->px等

**计算每个节点的具体样式**

继承：每个子节点都会默认继承父节点的样式属性，如果父节点中没有找到，就会采用浏览器默认样式，也叫UserAgent样式

层叠：css最大的特点在于它的层叠性，也就是最终的样式取决于各个属性共同作用的效果。在计算样式之后，所有的样式都会被挂在window.getComputedStyle当中，可以通过js来获取计算后的样式

#### 生成布局树

拿到生成好了的DOM树和DOM样式后，首先会对DOM树进行遍历，并添加到布局树中。然后浏览器的布局系统会根据DOM样式来确定元素的位置，最后生成一颗布局树

### 浏览器渲染过程

浏览器渲染过程有以下几个步骤

#### 建立图层树

**显示合成**

使用层叠上下文的节点，层叠上下文是有一些特定的CSS属性创建的，一般有以下情况：

HTML元素本身就具有层叠上下文

普通元素设置**position不为static**并且**设置了z-index属性**，会产生层叠上下文

元素的 **opacity** 值不是 1

元素的 **transform** 值不是 none

元素的 **filter** 值不是 none

元素的 **isolation** 值是isolate

will-change指定的属性值为上面任意一个。(will-change的作用后面会详细介绍)

还有需要裁剪的地方，比如一个div，里面的内容超出了出现滚动条，那么滚动条会被单独提升为一个图层

**隐式合成**

隐式合成就是层叠等级低的节点被提升为单独的图层之后，那么所有层叠登记比它高的节点都会成为一个单独的图层。隐式合成存在巨大的风险，当一个大型应用中，z-index比较低的元素被提升为单独的图层之后，层叠在它上面的元素都会被提升为单独的图层，可能会增加上千个图层，大大增加内存的压力，甚至让页面崩溃

#### 生成绘制列表

渲染引擎会将图层的绘制拆分成一个个绘制指令，比如先画背景再描绘边框，然后将这些指令俺顺序组合成一个待绘制列表，相当于给后面的绘制操作做了一波计划

#### 生成图块并栅格化

开始绘制的过程实际上是有专门的线程来完成的，这个线程叫做合成线程。考虑到页面非常大的时候，要滑很长时间才能滑到底，如果要一口气全部绘制出来是相当浪费性能的。因此合成线程要做的第一件事就是将图层分块。每一个图层块通常是256*256或则512*512大小的

因为图块数据是要进入GPU内存的，为了提高性能，Chrome在首次合成图块时会采用一个分辨率低的图片，这样展示的时候只是展示出低分辨率的图片，这个时候继续进行合成操作，当正常的土块内容绘制完毕后，会将当前低分辨率的图块内容替换

#### 显示器显示内容

当栅格化完成后，合成线程会生成一个绘制命令‘DrawQuad’并发送给浏览器

浏览器进程中的viz组件接受到这个命令，然后把页面内容发送到内存。然后发送到显卡

**显示器显示原理**

显示器都有一个固定的刷新频率，一般是60HZ，也就是一秒更新60张照片，每次更新的图片都是来自显卡的前缓冲区。显卡在接受到浏览器传来的页面后，会合成响应的图像，然后放入后缓冲区，然后系统自动将前缓冲区和后缓冲区对换位置，一直循环更新

### 重绘和回流（**避免频繁使用style，采用class的方式可以减少回流**）

#### 回流

回流又叫重排会重新生成DOM树

**触发条件**

简单来说，当我们对DOM结构的修改引发DOM几何尺寸变化的时候，会发生回流的过程

一个DOM元素的几何属性变化，常见的几何属性有width、height、padding、margin、left、top、border

使DOM节点发生增减或则移动

读写offset、sroll和client属性的时候，浏览器为了获取这些值，需要进行回流操作

调用window.getComputedStyle方法

#### 重绘

重绘直接刷新页面 ，不会重新生成DOM树

**触发条件**

当DOM的修改导致样式的变化，并且没有影响几何属性的时候，会导致重绘

### 合成

合成也叫GPU加速，CSS3的transform、opacity、filter可以实现合成的效果。在合成的情况下，会直接跳过布局和绘制流程，直接进入非主线程处理的部分，直接交给合成线程处理

**好处**

能偶发挥GPU的优势。合成线程生成位图的过程中会调用线程池，并在其中使用GPU进行加速生成，而GPU是擅长处理位图数据的

没有占用主线程的资源，即使主线程卡住了没效果依然能够流畅的展示